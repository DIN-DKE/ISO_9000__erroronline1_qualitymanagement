# provided modules within open-source distribution

i think it is self explanatory why i did not publish my companies contents as these are confidential. but the methods might be useful for everyone.

## document search
you can search for documents by name, switch between your own and foreign or other documents. there is a third category of documents of proof that might not neccessarily have to be in version control. these are not searchable but still reachable from the application.
every klick on a document will be counted. from the second call of this module on the last used documents will be displayed. frequent called documents will appear on the top of the list. you can define default documents, users will be able to define their own default list, delete and recall lists. if you define default lists within the module set up the documents filename only without non-word characters.

dependencies are: datalists for internal and external an other documents. these are generated by the excel-file of documents in force.

globalSearch api: returns documents from all categories/datalists that fit search terms.

## predefined document packages
if you have reaccuring sets of documents it might come in handy if you define packages that can be selected, displayed and (using ie11) printed on the fly.

dependencies are: datalist for packages. this can be generated by the excel file of documents in force. if you mess around with exceptions there might be changes within the macro neccessary as well.

globalSearch api: returns packages that fit search terms.

## inventory / stock list
if you want your employees to have a look at approved products and materials for your company and let them keep in touch with the inventory control this module makes it quite easy to look up all products.

dependencies are: the datalist of inventory and an excel file containing the original data exporting everything. the displayed data is according to the excel-lists column organisation. if something is changed here the filter-method might have to be adjusted. employees have the opportunity to support inventory control via email and keep them updated.

globalSearch api: returns number of matches regarding search terms.

excel might not be the best solution to keep track of your stock list. in my case my companies current solution still is worse. so this is quite an advance.

## default texts for correspondence
define default text blocks that you can use for standard letters so your company speaks consistent and no one has to think about wording for hours. you can define your default letter template to be accessible directly from this module to copy the texts on the fly.

dependencies are: datalists for texts

globalSearch api: returns texts blocks where headers match the search terms.

currently i have no idea how to set this one up with an easy office interface because language synthesis is quite complex in this simple approach already. this module makes use of the `core.function.languageSynthesis` properties within library/core/core.function.languageSynthesis.js, adding new texts might require flexible additions to this core-function with all language support and in my company i am not sure about the ability to comprehend inserting $placeholders$ to a text. so currently adding meaning to this module will definitively need an understanding of the code.

## mail tool
creating serial letters is an office feature, but sending almost the same email to different recipients while manually changing the salutation is not that much fun. automate this by using this module. all you have to to is to klick on the created links one after another and send the emails.
you can also define the default email signature for your company and make everyone using it by just modifying their name, position and email-address. this function should be mostly outlook-webapp-proof.
in case you are out of office, with this module you can set up the starting and ending time of your vacation and will get the text automatically.

this module has a slightly different structure than the others and you have to make your configuration regarding language and content not only on the top of the file.

no dependencies for this module

globalSearch api: returns submodules where titles match the search terms.

## help
use this as an implementaion to have your own modules and workflows documented. customize it to your own companies comprehension of interwebz and nerd-stuff-thingies)

dependencies are: datalist of help topics. these have to be written directly.

globalSearch api: returns entries that match search terms.

# module handling
be aware of these rules to handle your modules properly. these rules apply to submodules of the quality management assistant by
[error on line 1](http://erroronline.one)

## module structure
each module consists of an object with properties and methods. the initiating method should be the callback function of module loading with `core.function.loadScript('modules/modulename.js','modulename.function.init()')`. the overall structure of the modules data processing looks like this:

```Javascript
if (typeof modulename == 'undefined') var modulename={};

modulename.api= { //for globl search
	available: function(search){
		//stop performance monitoring that has been started by module calling
		core.performance.stop('modulename.api.available(\''+search+'\')');
		return somethingBasedOn(search);
	},
	processAfterImport: function(){
		//if you have to load something first this might be the callback function.
	}
};
modulename.function= { //module behaviour
	init: function(query){
		//highlight menu icon
		el('module{modulename}').checked=true; 
			el('module{modulename}').checked=true; 
		el('module{modulename}').checked=true; 
		//import data file if applicable, return initial module content, process query from inter-module communication or global search
		core.function.loadScript('library/module.data/modulename.js', 'modulename.function.someFunction(\'' + value(query) + '\')');
		//prepare your modules interface
		el('input').innerHTML='your menu';
		el('temp').innerHTML='your temporary output or additional forms';
		el('output').innerHTML='your output';
		//stop performance monitoring that has been started by module calling and write history
		core.performance.stop('modulename.function.init(\'' + value(query) + '\')');
		core.history.write(['modulename.function.init(\'' + value(query) + '\')']);
	},
	someFunction: function(query){
		//optinal performance monitoring for each function
		core.performance.start('modulename.function.someFunction(\'' + value(query) + '\')');
		
		//////////////////////////////////////////////////////
		//do your magic here
		//////////////////////////////////////////////////////

		core.performance.stop('modulename.function.someFunction(\'' + value(query) + '\')');
		core.history.write(['modulename.function.init(\'' + value(query) + '\')']);
	}
};
```

the folder data has to contain a variable-file for the module, that will be called automatically on module load.

```Javascript
if (typeof modulename == 'undefined') var modulename={};

modulename.var= { //module variables
	someProperty: 'Pi is exactly 3',
	lang: {
		inputPlaceholder: {
			en: 'Search for last digit of pi',
			de: 'Suche die letzte Stelle von Pi' 
		},
		otherShownText: {
			en: 'Add multi-language-support for all text chunks',
			de: 'Füge Unterstützung für mehrfache Sprachen für alle Text-Blöcke ein'
		}
	},
	//declare false if the output is meant to be copied and should be selected as a whole by clicking into the area
	disableOutputSelect: false,
};
```

thus algorithms and values are separated and changes on one don´t necessarily affect the other. or copying new content between my companies and this open source version don't overwrite something (that happend way to often). since both parts of module are loaded asynchronously the initialization of the modules object in both files might be reasonable.

please inspect the sample files for further information. while distributing this piece of software there happen to be some differencies between the open source version and the actual software used in my company. the main differencies can be found in the {modulename}.var-properties. maybe you find this suitable for you as well so changes to to sourcecode are way more easy to implement.

## module functions
modules must contain functions to generate the modules output. some functions are in the main or dependent scripts like language synthesis, shortened document.getElementByID() or loading remote scripts. make use of the core-object, some things are fairly prepared:

* data handling for inter module communication and storing settings
* html-escaping for urls and mailto:
* search algorithm
* language selection
* language synthesis as in replacing customizable keywords in strings
* asynchronous script loading
* insertion of repetitive html-elements (e.g. inputs) 
* insertion of inline svg

all modules are depentent on the main module, only some may have dependencies of other data-files.

## output containers
container for output are named 'input', 'temp' and 'output' and can be accessed via `el('input').innerHTML` or whatever.

## registering and loading of modules
register and deregister modules in ROOT/core/config.js so they are accessible and listed on initial start. import js-files or other subscripts with `core.function.loadScript(url,callback);` files to be imported always have to be hardcoded (e.g. dropdown-list) because javascript having no indirect access to local file system (directory-listing etc.). this has to be done within modules as well. data-objects should be stored in library/module.data/ prefixed with modulename_. therefore these can remain untouched if any changes occur for the main module-file and won't be affected during file-transfers in reviews.

## module initialization
initialization of module will be achieved by the callback functions of the core.function.loadScript-method. initialization should contain a default output for input (forms or explanatory text), might contain module information in temp and should clear output. even if the module-object is reinitialized on every module-call there is no way of initializing with the same function name because of some asynchronous variable handling or scope unknown to me resulting in calling the previous init-function and giving a lot of errors.

## multi-language support
the language bricks within the modules are to be defined. i recommend the same nesting and pattern than the core language model for easier source reading. within every module the language-blocks have to be filled up according to registered languages to avoid errors of undefined objects. the bricks can be called with `core.function.lang('brickName','modulename')` and will return the block in the selected language.

## language synthesis
the root language model core.function.languageSynthesis within the file library/core/core.function.languageSynthesis.js can be extended through assigning an additional property within the module-file for example:

```Javascript
core.function.languageSynthesis.property={
	registeredlanguage_1:['child male form', 'child female form', 'adult male form', 'adult female form'],
	registeredlanguage_2:['child male form', 'child female form', 'adult male form', 'adult female form']
	};
```

or

```javascript
core.function.languageSynthesis.property={
	registeredlanguage_1:function(){/*todo*/ return value;},
	registeredlanguage_2:function(){/*todo*/ return value;},
	);
```

the former object structure absolutely makes sense in german. in english not really though but it is implemented that way, so if you want to reduce that you will have to make changes to the processing as well. you can make use of these properties by processing strings as e.g.

```javascript
'this is a text where the term $property$ will be replaced.'.replace(/\$(\w+?)\$/ig,function(match,group1){return core.function.languageSynthesis.output(group1)});
```

the method handles the decision over values or functions on its own.

## smart search with fuzzy search
i have to admit i am a bit proud of this one. this method has to be handed over the raw query string and an object containing the searchable data. it then splits the query into whitespace separated terms, divides -filters and adds a concatenated query to an array of query options. fuzzy search is optional and can be enabled from the settings. if the query bits are set up the dataset will be checked for occurences of every bit. the results is a multidimensional array that can be displayed first in order of occurrences of different terms (if there are more than one) then of the data object.

## output usage
output text is selected on click by default. to avoid this add a property `disableOutputSelect=true;` to module.var. this is considered not to be implemented global through registered-modules for being dynamically mutable if desired within the module itself (e.g. see mailtools).

## inter-module communication
communication between modules is possible with use of localstorage or cookies. this has to be observed strictly, because of possible failures and dependencies of js-data-files. there might be spaghetti! use the `core.function.setting` method and always make sure to have proper default and error handling in case of missing data. initiating functions of submodules partially accept queries to handle preselections.

## api
every module has to contain an api-method that returns some value (at least a `return;`). the api-module is called by the global search from the start site. lack of the api will result in errors. every registered module will be called even if the user has deselected it in the settings (so the user might get a feeling of content and meaning of modules and has a guaranteed meaningful access).

## merely a matter of form
i recommend not testing in production... this whole thing escalated a bit in regards of complexity. as this is a read-only application it is absolutely possible to adjust within a developement version and push to production later on. there might be some caution neccessary with overwriting the data-files but this is the reason for them to be stored within a different folder.

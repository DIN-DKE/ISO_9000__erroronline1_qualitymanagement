# provided modules within open-source distribution

i think it is self explanatory why i did not publish my companies contents as these are confidential. but the methods might be useful for everyone.

## document search
you can search for documents by name, switch between your own and foreign documents. there is a third category of documents of proof that might not neccessarily have to be in version control. these are not searchable but still reachable from the application.
every klick on a document will be counted. from the second call of this module on the last used documents will be displayed. frequent calles documents will appear on the top of the list. you can define default documents, users will be able to define their own default list, delete and recall lists. if you define default lists within the module set up the documents filename only without non-word characters.

dependencies are: datalists for internal and external documents. these are generated by the excel-file of documents in force.

## predefined document packages
if you have reaccuring sets of documents it might come in handy if you define packages that can be selected, displayed and (using ie11) printed on the fly.

dependencies are: datalist for packages. this can be generated by the excel file of documents in force. if you mess around with exceptions there might be changes within the macro neccessary as well.

## inventory / stock list
if you want your employees to have a look at approved products and materials for your company and let them keep in touch with the inventory control this module makes it quite easy to look up all products.

dependencies are: the datalist of inventory and an excel file containing the original data exporting everything. the displayed data is according to the excel-lists column organisation. if something is changed here the filter-method might have to be adjusted. employees have the opportunity to support inventory control via email and keep them updated.

excel might not be the best solution to keep track of your stock list. in my case my companies current solution still is worse. so this is quite an advance.

## default texts for correspondence
define default text blocks that you can use for standard letters so your company speaks consistent and no one has to think about wording for hours. you can define your default letter template to be accessible directly from this module to copy the texts on the fly.

dependencies are: datalists for texts

currently i have no idea how to set this one up with an easy office interface because language synthesis is quite complex in this simple approach already. this module makes use of the `core.function.languageSynthesis` properties within core/core_language_synthesis.js, adding new texts might require flexible additions to this core-function with all language support and in my company i am not sure about the ability to comprehend inserting $placeholders$ to a text. so currently adding meaning to this module will definitively need an understanding of the code.

## mail tool
creating serial letters is an office feature, but sending almost the same email to different recipients while manually changing the salutation is not that much fun. automate this by using this module. all you have to to is to klick on the created links one after another and send the emails.
you can also define the default email signature for your company and make everyone using it by just modifying their name, position and email-address. this function should be mostly outlook-webapp-proof.
in case you are out of office, with this module you can set up the starting and ending time of your vacation and will get the text automatically.

this module has a slightly different structure than the others and you have to make your configuration regarding language and content not only on the top of the file.

no dependencies for this module

## help
use this as an implementaion to have your own modules and workflows documented. customize it to your own companies comprehension of interwebz and nerd-stuff-thingies)

dependencies are: datalist of help topics. these have to be written directly.

# module handling
be aware of these rules to handle your modules properly. these rules apply to submodules of the quality management assistant by
[error on line 1](http://erroronline.one)

## module functions
modules must contain functions to generate the modules output. some functions are in the main or dependent scripts like language synthesis, shortened document.getElementByID() or loading remote scripts. make use of the core-object, some things are fairly prepared:

* data handling for inter module communication and storing settings
* html-escaping for urls and mailto:
* search algorithm
* language selection
* language synthesis as in replacing customizable keywords in strings
* asynchronous script loading
* insertion of repetitive html-elements (e.g. inputs) 
* insertion of inline svg

all modules are depentent on the main module, only some may have dependencies of other data-files.

## output containers
container for output are named 'input', 'temp' and 'output' and can be accessed via `el('input').innerHTML` or whatever.

## registering and loading of modules
register and deregister modules in ROOT/core/config.js so they are accessible and listed on initial start. import js-files or other subscripts with `core.function.loadScript(url,callback);` files to be imported always have to be hardcoded (e.g. dropdown-list) because javascript having no indirect access to local file system (directory-listing etc.). this has to be done within modules as well. data-objects should be stored in data/ prefixed with modulename_. therefore these can remain untouched if any changes occur for the main module-file and won't be affected during file-transfers in reviews.

## module initialization
initialization of module has to be with function-name exactly like module-name and calling the initiating function at the end
of the module-name. initialization should contain a default output for input (forms or explanatory text), might contain
module information in temp and should clear output. even if the module-object is reinitialized on every module-call there is no way of initializing with the same function name because of some asynchronous variable handling or scope unknown to me resulting in calling the previous init-function and giving a lot of errors.

## multi-language support
the language bricks within the modules are to be defined. i recommend the same nesting and pattern than the core language model for easier source reading. within every module the language-blocks have to be filled up according to registered languages to avoid errors of undefined objects. the bricks can be called with `core.function.lang('brickName')` and will return the block in the selected language.

## language synthesis
the root language model core.function.languageSynthesis within the file core\core_language_synthesis.js can be extended through assigning an additional property within the module-file for example:

```Javascript
core.function.languageSynthesis.property={
	registeredlanguage_1:['child male form', 'child female form', 'adult male form', 'adult female form'],
	registeredlanguage_2:['child male form', 'child female form', 'adult male form', 'adult female form']
	};
```

or

```javascript
core.function.languageSynthesis.property={
	registeredlanguage_1:function(){/*todo*/ return value;},
	registeredlanguage_2:function(){/*todo*/ return value;},
	);
```

the former object structure absolutely makes sense in german. in english not really though but it is implemented that way, so if you want to reduce that you will have to make changes to the processing as well. you can make use of these properties by processing strings as e.g.

```javascript
'this is a text where the term $property$ will be replaced.'.replace(/\$(\w+?)\$/ig,function(match,group1){return core.function.languageSynthesis.output(group1)});
```

the method handles the decision over values or functions on its own.

## smart search with fuzzy search
i have to admit i am a bit proud of this one. this method has to be handed over the raw query string and an object containing the searchable data. it then splits the query into whitespace separated terms, divides -filters and adds a concatenated query to an array of query options. fuzzy search is optional and can be enabled from the settings. if the query bits are set up the dataset will be checked for occurences of every bit. comparison happens for word-characters only (regex \w). the results is a multidimensional array that can be displayed first in order of occurrences of different terms (if there are more than one) then of the data object.

## output usage
output text is selected on click by default. to avoid this add `var disableOutputSelect=true;` to module script. this is considered not to be implemented global through registered-modules for being dynamically mutable if desired in future modules

## inter-module communication
communication between modules is possible with use of localstorage or cookies. this has to be observed strictly, because of possible failures and dependencies of js-data-files. there might be spaghetti! use the `core.function.setting` method and always make sure to have proper default and error handling in case of missing data.

## merely a matter of form
i recommend not testing in production... this whole thing escalated a bit in regards of complexity. as this is a read-only application it is absolutely possible to adjust within a developement version and push to production later on. there might be some caution neccessary with overwriting the data-files but this is the reason for them to be stored within a different folder.
